== About RubyWrite

RubyWrite is an embedded tree rewriting DSL (Domain-Specific Language) aimed
at providing an infrastructure for developing program transformation tools in
Ruby, especially at the source level.  RubyWrite is inspired by
Stratego[http://strategoxt.org/].  Embedding within Ruby makes the full
flexibility and power of Ruby available to the tool writer while providing the
brevity and elegance of using a DSL for specifying tree transformations.


== Downloading and Installing RubyWrite

RubyWrite can be installed as a Ruby gem (URL to come).  Meanwhile it can be
downloaded from an {SVN repository}[https://phi.cs.indiana.edu/svn/RubyWrite].
There is nothing to install, except adding the +lib+ directory to the load
path for +require+ when downloaded using Subversion.


== Using RubyWrite

RubyWrite is a tree-transformation library, implemented as an embedded DSL
within Ruby.  The tree that the library transforms is represented in a format
similar to ATerm[http://www.program-transformation.org/Tools/ATermFormat], but
without the annotations (at least, for now).  It is a recursively specified
tree, starting at the root.  A tree node is either a leaf node (string or
symbol), a named internal node, or an unnamed internal node.  A node's children
are specified using square-brackets (<tt>[]</tt>).  Following are examples of
valid trees.

* String
        'some other node'
* Named internal node with no child
        :root[]
* Named node with one child
        :top[:one]
* Named node with three children
        :parentOfThree['one', :two, :two]
* Named node with children and grandchildren
        :ForLoop[:lowerLimit['1'], :upperLimit['100'], :body[:stmtList]]

Presumably, a tree gets generated by a parser, which is then transformed using
RubyWrite.  All leaf nodes in a parse tree are of <tt>String</tt> type.

Trees can also be constructed explicitly to serve as patterns to be matched
against, or as specifications to build (instantiate) new parse trees.  Such
trees may contain leaf nodes that are <tt>Symbol</tt> objects.  If performing
a match the <tt>Symbol</tt> nodes generate new bindings and serve to unify the
match (if a single symbol occurs multiple times in the pattern).  If
performing a build the <tt>Symbol</tt> nodes trigger look-ups in the current
environment.

In order to write a transformer the user defines a transformer class that
extends the RubyWrite::ReWriter class.  The new class must contain a method
named +main+ or <tt>main!</tt>.

  class Transformer < RubyWrite::ReWriter
    def main
      ...
    end
  end

The +Transformer+ class is used by calling <tt>Transformer.run</tt> that
automatically creates a +Transformer+ instance and calls +main+, or
<tt>main!</tt> if +main+ is not defined.  The tree to be transformed is the
+Node+ object passed to <tt>Transformer.run</tt>.  Notice that it is possible
to call <tt>Transformer.run</tt> multiple times, although each call will create
a new instance of +Transformer+.  Nested transformers should be fine (but, have
not been tested yet).

In addition to +main+ or <tt>main!</tt> other methods may be defined within the
+Transformer+ class and used as usual.  RubyWrite follows the Ruby convention
of ending the names of methods with side-effects with a <tt>!</tt>.  Thus, all
traversal methods that can potentially change the object they are passed end
with <tt>!</tt>.  Similarly, methods returning Boolean values end in
<tt>?</tt>.  Each traversal method has a corresponding Boolean variant.

Each method also gets its own environment, which is the bindings of Symbol
objects to subtrees.  The only exceptions to this are <tt>match</tt>, where we
*want* the method to change the callers environment, and <tt>build</tt> where
want to be able to access the surrounding environment for looking up Symbols.

Blocks passed to methods share the environment of the surrounding method, just
as local variables in standard Ruby.


== RubyWrite Primitives and Modules

=== Primitives

* match? pattern, tree

  <tt>match?</tt> matches the first argument (the pattern) against its second
  argument (the tree) and updates the environment by binding symbols in leaf
  positions of the pattern to sub-trees in the supplied tree.  <tt>match?</tt>
  may also be passed an optional block, which is executed <b>after</b> the
  matching.  The block is passed the matched tree as an argument.  This is
  often convenient as a post-processing step.  The block does not get called if
  matching fails.  <tt>match?</tt> uses its caller's environment.

* match pattern, tree

  <tt>match</tt> works similarly to <tt>match?</tt> except that a +Fail+
  exception gets thrown if the match fails.

* build spec

  <tt>build</tt> takes a specification (a valid tree) to build and return a new
  tree.  It may also be passed an optional block which is executed
  <b>before</b> the build.  <tt>build</tt> uses the same environment as its
  caller.

* try node {|n| ...}

  <tt>try</tt> executes the given block, passing it +node+ as an argument,
  within the current environment.  If the block fails (returns <tt>false</tt>
  or <tt>nil</tt>) any changes to the environment are rolled back.  Otherwise,
  the changes are committed.  <tt>try</tt> returns the value returned by the
  block.

* set! sym, node

  <tt>set!</tt> explicitly sets the value of <tt>sym</tt> to +node+.

* lookup sym

  <tt>lookup</tt> looks up the value of <tt>sym</tt> in the current
  environment.  <tt>sym</tt> must be a previously matched <tt>Symbol</tt> type.


=== Module: Traversals

* +one+ one

* +all+ all

* +topdown+ top down

* +bottomup+ bottom up

* +alltd+ all top down


=== Module: Collectives

* <tt>hash_map node</tt>: The <tt>hash_map</tt> method takes a parse tree
  +node+ and a block.  The block is expected to consist only of a sequence of
  <tt>rule</tt>s.  Each +rule+ specifies a pattern to match and the block of
  code to be executed when the given +node+ matches that pattern.  If the
  pattern specified in a +rule+ matches then its block is executed by first
  setting up a new environment which is initialized by the matched symbols, if
  any.  The patterns specified by any two rules must not overlap.  In other
  words, it should not be possible to build a single valid parse tree that
  could match more than one rule.  This requirement is not enforced, but may
  lead to unexpected results if violated.  An optional default rule may be
  specified that gets executed if no other rule matches.

  <em>Example to come</em>


== Mixing Functional and Imperative Styles

While RubyWrite follows a more-or-less functional approach, embedding
it in Ruby means that all the imperative constructs are also available to a
programmer.  This is a deliberate decision because compilers are often most
conveniently written with some global information.  Moreover, many data
structures, such as graphs, are hard to implement efficiently within pure
functional settings.

In designing RubyWrite there was a choice between implementing the primitives
with guarantees against side-effects in the event of failure and letting the
partial side-effects show in the case of failures.  For example, a call to
+match+ might have modified the caller's environment when it fails.  Instead of
guaranteeing against the pollution of caller's environment in such cases,
RubyWrite takes the stance that failures are exceptional situations.  The
application is likely to exit after such a failure or, at least, preserving the
caller's environment is unlikely to be important in the event of a failure.
Therefore, it is worthwhile optimizing the method calls for the common case of
success.  On the other hand failure mode can genuinely be used as a programming
technique.  For such cases RubyWrite provides the <tt>try</tt> primitive for
explicit protection from the side-effects of a piece of code that might fail.


== Examples

* Reverse a For-loop
    if (match? :For[:idx, :lower, :upper, :body], loop)
        x = build :For[:idx, :upper, :lower, :body]
    end

* Process the body of a while-loop with helper function
    loop.match?(:While[:condExp, :body]), apply{ result = helper_function lookup(:body) }


* Process an explicitly constructed subtree with a helper function
    result = helper_function :If[:Exp[:Binop[:Var['x'],'<',:Var['0']]],
			     :Assign[:Var['y'],:Const['0']],
			     :Assign[:Var['y'],:Var['x']]]

* Invoke method on matched subtrees
    if (match? :While[:cond, :body], loop)
       match? :While[:nCond, :nBody], lookup(:body)
    end

  Alternatively,
    loop.match?(:While[:condExp, :body]), apply{ match :While[:nCond, :nBody], lookup(:body) }


* Using match? on a node without a block (but still need to supply one to use this syntax)
    loop.match? :While[:cond, :body], apply{}

* Convert all assignments to lets.  The apply syntax makes more sense with traversals.
    prog.alltd! apply{|n| build :Let[:x, :y] if match?(:Assign[:x, :y], n) }

* Is there any function call in the body?  If so, set :call to the first one.
    body.topdown? apply{|n| n.match? :FunCall[:_, :_] apply{|f| set! :call, f}}
