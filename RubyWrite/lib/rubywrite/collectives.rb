require 'rubygems'
require 'trie'

# RubyWrite:;Collectives defines a convenient way for defining simple rewrite
# rules using the define_rw_rewriter method at definition time to provide a way
# to match small blocks of code with unique patterns.
#
# Example:
#   
#   class MyTransformer
#     include RubyWrite::Basics
#     include RubyWrite::Collectives
#
#     define_rw_rewriter :my_rewriter do
#       rewrite pattern1 { |node| ... }
#       rewrite pattern2 { |node| ... }
#       rewrite pattern3 { |node| ... }
#
#       default { |node| ... }
#     end
#   end
#
# This will define a new method 'my_rewriter' that can be called within the
# class as an instance method, just like any other instance method.
# my_rewriter will take one argument, the node to be manipulated.
#
module RubyWrite
  module Collectives
    include RubyWrite::ReWriter

    # The RubyWrite::Collectives::Rules is an internal class in the Collectives
    # module used to keep track of the Trie and default method settings for
    # a rewriter.  Each rewrite consists of a pattern and a bit of code that
    # handles the pattern when it is discovered in a piece of source code.
    # 
    # In general Rules should not be used directly, but rather used through
    # the define_rw_rewriter class method included with the 
    # RubyWrite::Collectives module.
    class Rules
      def initialize
        @trie = Trie.new
        @default_exists = false
      end

      # rewrite defines a new rewrite translation rule for the rewriter
      # currently being defined. It expects a unique pattern to match and a
      # block for processing it when it is discovered.
      #
      # Example:
      #   rewrite :For[:var,:start,:end,:body] { |node| ... }
      #
      def rewrite node, &code
        if !node.instance_of?(Node)
          raise Fail.new "Expected Node type, given #{node.class} (#{node})"
        end
        @trie.insert node.hash_key, [node, code]
      end

      # default defines a rule to use when none of the rewrite patterns match
      # the node currently being processed.  This can be particularly useful
      # for cases where you wish to recur through a tree, but are only changing
      # a handful of nodes.
      #
      # Example:
      #   default { |node| ... }
      #
      def default &code
        @trie.insert "rule#default", [nil, code]
        @default_exists = true
      end

      # apply is used internally by the method generated by define_rw_rewriter
      # to call.
      #
      # Note: that this code expects to be passed the instance of the current
      # transformer in order to apply the rule.
      def apply xfer, node, *args
        raise Fail.new("RubyWrite::Rules#apply: Unexpected nil node") if !node
        if (t = node.hash_lookup @trie).size > 1
          raise Fail.new "RubyWrite::Rules#apply: Expecting to find one " \
          "entry in the trie, found #{t.size}, while matching " \
          "#{node.to_string}"
        end
        begin
          saved_env = xfer.env
          xfer.env = Environment.new
          pattern,code = t.values[0] if (t.size == 1)
          if (!pattern or !xfer.match?(pattern,node)) && @default_exists
            t = @trie.find_prefix 'rule#default' # t = 'rule#default'.hash_lookup @trie
            pattern,code = t.values[0] # guaranteed to find the default case
          end
          raise Fail.new "RubyWrite::Rules#apply: No rule to match #{node.to_string}" if !code
          xfer.instance_exec node, *args, &code
        ensure
          xfer.env = saved_env
        end
      end
    end

    module ClassMethods
      # Defines a new RubyWrite rewriter method for use in a RubyWrite
      # transformer.  A rewriter comprises a set of rewrite rules defined with
      # the rewrite function.
      #
      # Example:
      #
      #   define_rw_rewriter :reverser do
      #     rewrite :For[:var,:start,:end,:stmt] do
      #       build :For[:var,:end,:start,reverser(lookup(:stmt))]
      #     end
      #
      #     default do |node|
      #       case node
      #       when RubyWrite::Node then
      #         node.children.map! { |child| reverser child }
      #         node
      #       when Array then node.map { |child| reverser child }
      #       when String then node
      #       end
      #     end
      #   end
      #
      #   This will define a new instance method "reverser" that expects a
      #   node and traverses the node replacing every instance of a for loop
      #   from n to m with a for loop from m to n.
      #
      def define_rw_rewriter name, &blk
        r = Rules.new
        r.instance_exec &blk
        define_method name do |*args|
          r.apply self, *args 
        end
      end
    end

    # :nodoc:
    #
    # Extra little function here to cause our ClassMethods to be included as
    # class methods of any module that includes the collectives library.
    def self.included base
      base.extend RubyWrite::ReWriter::ClassMethods
      base.extend ClassMethods
    end

    ## The original implementation of this code.
  end
end


module RubyWrite
  class Node
    # Internal method used to calculate a key for the trie used to store
    # a pattern in the Trie used by the rewriter functionality.
    def hash_key
      "#{@value}##{@children.length}"+@children.hash_key
    end

    # A lookup method for searching the rewriter trie for the current node
    # pattern.
    def hash_lookup trie
      t = trie.find_prefix "#{@value}##{@children.length}"
      if t.size <= 1
        t
      else
        @children.hash_lookup t
      end
    end
  end
end

class String
  # Internal method used to calculate a key for the trie used to store
  # a pattern in the Trie used by the rewriter functionality.
  def hash_key
    "'#{self}'"
  end

  # A lookup method for searching the rewriter trie for the current node
  # pattern.
  def hash_lookup trie
    trie.find_prefix "'#{self}'"
  end
end

class Array
  # Internal method used to calculate a key for the trie used to store
  # a pattern in the Trie used by the rewriter functionality.
  def hash_key
    each.inject("[") {|s,c| s + c.hash_key} + "]"
  end

  # A lookup method for searching the rewriter trie for the current node
  # pattern.
  def hash_lookup trie
    t = trie.find_prefix "["
    return t if t.size <= 1
    each do |c|
      if t.keys[0][0] == '_' # the pattern has a symbol to match here, so no need to match this child
        t = t.find_prefix '_'
      else
        t = c.hash_lookup t
      end
      return t if t.size <= 1
    end
    t.find_prefix "]"
  end
end

class Symbol
  # Internal method used to calculate a key for the trie used to store
  # a pattern in the Trie used by the rewriter functionality.
  #
  # Note: raw symbols are used to represent variables to be filled during a
  #       match in the rewrite pattern
  def hash_key
    "_"
  end

  # A lookup method for searching the rewriter trie for the current node
  # pattern.
  #
  # Note: raw symbols are used to represent variables to be filled during a
  #       match in the rewrite pattern, hence we should not find them in the
  #       concrete node being used to find a rewrite code block in the trie.
  def hash_lookup trie
    raise RubyWrite::Fail.new "Symbol::hash_get_value: Unexpected call on Symbol :#{self}"
  end
end
